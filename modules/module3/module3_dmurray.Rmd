---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
data_dir <- "/home/shared/data"
scripts_dir <- "/home/shared/R"
source(file.path(scripts_dir, "submission_helpers.R"))
```

## Cell line gene expression data, input and manipulate as in Module 1

```{r}
load(file.path(data_dir, "pson_expr_tpm_df.RData"))
```

```{r}
#How do you see what is included in this df? Run the command. 



```

```{r}
#What are the sample names in pson_expr_tpm_df?


#How are genes identified?


```

```{r}
#Andrew taught us many ways to inspect the data. Try this one.

View(pson_expr_tpm_df)

```

As you learned, the gene IDs are not very informative â€” they come from a database called ENSEMBL. More commonly, we would use the Hugo gene symbols (https://www.genenames.org/). These are the gene names you are more used to seeing (MYC, BRCA1, etc). We have this information stored in another file.

```{r}
load(file.path(data_dir, "pson_expr_gene_info.RData"))
```

```{r}
#head(gene_df)
convert_ENSG_HUGO_df<-gene_df[,c(1,3)]
head(convert_ENSG_HUGO_df)
```

Recall what the function merge does. Succint and powerful!

```{r}
pson_expr_tpm_df2 <- merge(x = gene_df, y = pson_expr_tpm_df, 
                           by.x = "gene_id", by.y = "gene_id")
pson_expr_tpm_df2[1:5, 1:9] # view a few more columns this time
```

```{r}
pson_tpm_mat <- as.matrix(pson_expr_tpm_df2[, -c(1:5)]) 
rownames(pson_tpm_mat) <- pson_expr_tpm_df2$symbol
pson_tpm_mat[1:5, 1:5]
```

```{r}
pson_logtpm_mat <- log2(1 + pson_tpm_mat)
pson_logtpm_mat[1:5, 1:5]
```

We will us the function "prcomp()" to run the principal component analysis algorithm. "prcomp()" takes a matrix as input where the samples (cell lines) are the rows, and the features (transcript counts) are the columns.

```{r}
pson_mat<-t(pson_logtpm_mat)

#I will the eighth row (cell line) now because it is not included in the motility data frame.
#This is cheating a bit, but it makes life easier given our time constraints.
#I figured this out by matching the cell lines from the expression and motility data.

pson_mat<-pson_mat[-8,]   

```

As described in our lecture, there are two additional things for us to consider. 1) The data should be mean centered around 0, and 2) the data should be scaled so that the standard deviation for each gene is 1. Our features have the same units, and it is often the case that they are not scaled; this is somewhat subjective. "prcomp()" automatically mean centers the data for us.  Scaling is up to us.

```{r}
PCA_PSON<-prcomp(pson_mat, scale=FALSE)

```

Exciting, right?  But now we can get to our exploratory analysis.  What goodies does PCA_PSON hold for us?

```{r}
names(PCA_PSON)
```

We discussed these in the lecture. To summarize:
"sdev": The standard deviation of the principal components
"rotation": The matrix of feature loadings (weights)
"center": The feature means that prcomp() subtracted from each feature
"scale": The feature standard deviations used in scaling
"x": Coordinates of the cell lines projected onto the principal components

```{r}
dim(PCA_PSON$sdev)
dim(PCA_PSON$rotation)
dim(PCA_PSON$center)
dim(PCA_PSON$scale)
dim(PCA_PSON$x)
```

Are these dimensions what you would expect?

```{r}

PCA_PSON$rotation[1:5, 1:5]

```
```{r}

PCA_PSON$x[1:5,1:5]

```


```{r}
length(PCA_PSON$sdev)
length(PCA_PSON$center)
length(PCA_PSON$scale)
```

Check the values out! Why does scale have length 1?

Has PCA reduced the dimensionality of our data? Let's examine the importance of the principal components by ploting the percentage of variance explained. 

```{r}

pve<-100*PCA_PSON$sdev^2/sum(PCA_PSON$sdev^2)

par(mfrow=c(1,2))

plot(pve, type="o", ylab="PVE", xlab="Principal Component", col="blue")

plot(cumsum(pve), type="o", ylab="Cumulative PVE", xlab="Principal Component", col="brown3")
```

The first two PCs account for a lot of the variance, > 40%.  The first 10 PCs account for almost all of the variance.  Let's see if the first two PCs, PC1 and PC2, reveal any patterns in our data.

```{r}

plot(PCA_PSON$x[,1:2], pch=19, xlab="Projection onto PC1", ylab="Projection onto PC2")

```

Each point gives the coordinates of a sample/cell line in PC space.
It's a nice pattern with some potential.  Does is have meaning for our data set?
Let's color the points by cell line type and diagnosis.

```{r}

load(file.path(data_dir, "pson_motility_tidy_df.RData"))

cell_speeds_df <- subset(pson_motil_tidy_df, summary_metric == "speed_um_hr")

names(cell_speeds_df)

```

We will color by "cellLine" and "diagnosis", and it is possible to explore other relationships as well.

Here is a simple function for coloring points by type:

```{r}

csbc_Color=function(vec){
  
nn<-length(unique(vec))
  
csbc_cols=rainbow(nn,start=0,end=max(1,nn-1)/nn)
  
return(csbc_cols[as.numeric(as.factor(vec))])

}
```

```{r}

par(mfrow=c(1,2))

plot(PCA_PSON$x[,c(1,2)],col=csbc_Color(cell_speeds_df$cellLine), pch=19)

plot(PCA_PSON$x[,c(1,2)],col=csbc_Color(cell_speeds_df$diagnosis), pch=19)

```

```{r}

plot(PCA_PSON$x[,c(1,2)],pch=".") 
text(PCA_PSON$x[,c(1,2)],labels=cell_speeds_df$cellLine,pos=2,cex=0.7)

```

```{r}

plot(PCA_PSON$x[,c(1,2)],pch=".") 
text(PCA_PSON$x[,c(1,2)],labels=cell_speeds_df$diagnosis,pos=2,cex=0.7)

```

We see a nice pattern in the data:  In (PC1,PC2) space, the cell lines are nicely separated.
Note that the two breast cancer cell lines do NOT cluster together.

We can perform additional principal components analyses on cell line specific data. 


